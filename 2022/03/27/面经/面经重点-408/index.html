<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="elegantlee"><meta name="copyright" content="elegantlee"><meta name="generator" content="Hexo 5.4.1"><meta name="theme" content="hexo-theme-yun"><title>面经重点-408 | 天下武功，无坚不破，唯快不破</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="dns-prefetch" href="https://cos.yunyoujun.cn"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"elegantlee.github.io","root":"/","title":"新时代无产者","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><script src="/h" async></script><script src="/t" async></script><script src="/t" async></script><script src="/p" async></script><script src="/s" async></script><script src="/:" async></script><script src="/" async></script><script src="/" async></script><script src="/c" async></script><script src="/d" async></script><script src="/n" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><script src="/d" async></script><script src="/e" async></script><script src="/l" async></script><script src="/i" async></script><script src="/v" async></script><script src="/r" async></script><script src="/." async></script><script src="/n" async></script><script src="/e" async></script><script src="/t" async></script><script src="/" async></script><script src="/n" async></script><script src="/p" async></script><script src="/m" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/" async></script><script src="/d" async></script><script src="/i" async></script><script src="/s" async></script><script src="/t" async></script><script src="/" async></script><script src="/i" async></script><script src="/o" async></script><script src="/n" async></script><script src="/i" async></script><script src="/c" async></script><script src="/o" async></script><script src="/n" async></script><script src="/s" async></script><script src="/." async></script><script src="/j" async></script><script src="/s" async></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-71DVTQCBDW"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-71DVTQCBDW');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-MDZGC5R');</script><!-- End Google Tag Manager --><meta name="description" content="前端知识重点回顾">
<meta property="og:type" content="article">
<meta property="og:title" content="面经重点-408">
<meta property="og:url" content="https://elegantlee.github.io/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/index.html">
<meta property="og:site_name" content="天下武功，无坚不破，唯快不破">
<meta property="og:description" content="前端知识重点回顾">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/image-20220326155900535.png">
<meta property="og:image" content="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/c42bc6f45451457fa6d614fb27534516_tplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/9dbde0322cc1482fa17b38a4e3bfe664.jpg">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa80b3b48a84bd18d8e708c56a1dc22~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png">
<meta property="article:published_time" content="2022-03-27T04:16:37.144Z">
<meta property="article:modified_time" content="2022-03-31T03:52:12.970Z">
<meta property="article:author" content="elegantlee">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/image-20220326155900535.png"><script src="/js/ui/mode.js"></script>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="elegantlee"><img width="96" loading="lazy" src="/images/avatar3.jpg" alt="elegantlee"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">elegantlee</a></div><span class="site-name">天下武功，无坚不破，唯快不破</span><sub class="site-subtitle">修炼计算机科学内功</sub><div class="site-desciption">Talk is cheap, show me your code!!!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">8</span></a></div></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=641731718&amp;website=www.oicqzone.com" title="QQ 641731718" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ElegantLee" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=428084429" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/li-biao-26-93" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/347714868" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/elegantlee2" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:superlee666@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-HTTPS-%E5%92%8C-HTTP"><span class="toc-number">1.</span> <span class="toc-text">1. HTTPS 和 HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-https%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%85%AC%E7%A7%81%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 https如何保证安全的？加密方式？公私钥交换过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E7%90%86%E8%A7%A3XSS%EF%BC%8CCSRF%EF%BC%8CDDOS%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%81%BF%E5%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2理解XSS，CSRF，DDOS攻击原理以及避免方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Cookie、sessionStorage、localStorage 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">cookie的安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E6%88%90%E5%88%86"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 HTTP报文的组成成分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-http2-0%E5%92%8Chttp1-0"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 http2.0和http1.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-https%E5%92%8Chttp"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 https和http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#https-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">https 协议的工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7HTTP%E7%BC%93%E5%AD%98%EF%BC%88%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-amp-amp-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">1.7HTTP缓存（强制缓存&amp;&amp;协商缓存）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-HTTP%E5%8D%8F%E8%AE%AE-TCP%E5%8D%8F%E8%AE%AE-Scoket%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 HTTP协议, TCP协议, Scoket协议的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 HTTP常用的请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.1.</span> <span class="toc-text">GET和POST的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-0-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.10.</span> <span class="toc-text">2.0 HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.10.1.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">常见状态码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 跨域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. 从输入URL到页面加载的全过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%88%B0%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">5. TCP&#x2F;IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">TCP&#x2F;IP网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.2.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.3.</span> <span class="toc-text">TCP 四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text">TCP和UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-DNS%E4%B8%8ECDN"><span class="toc-number">6.</span> <span class="toc-text">6. DNS与CDN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">7. 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 进程和线程的区别与联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 进程间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%AD%BB%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">8. 常见数据结构</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://elegantlee.github.io/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="elegantlee"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="天下武功，无坚不破，唯快不破"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面经重点-408<a class="post-edit-link" href="https://github.com/ElegantLee/elegantlee.github.io/tree/hexo/source/_posts/面经/面经重点-408.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-03-27 12:16:37" itemprop="dateCreated datePublished" datetime="2022-03-27T12:16:37+08:00">2022-03-27</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-03-31 11:52:12" itemprop="dateModified" datetime="2022-03-31T11:52:12+08:00">2022-03-31</time></div><span class="leancloud_visitors" id="/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/" data-flag-title="面经重点-408"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-chat-3-line"></use></svg> <span class="waline-comment-count" id="/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E9%9D%A2%E7%BB%8F/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">面经</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%89%8D%E7%AB%AF/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">前端</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="1-HTTPS-和-HTTP"><a href="#1-HTTPS-和-HTTP" class="headerlink" title="1. HTTPS 和 HTTP"></a>1. HTTPS 和 HTTP</h1><blockquote>
<ol>
<li>介绍一下https，讲一下http2.0，它性能上有什么缺陷</li>
<li></li>
</ol>
</blockquote>
<h2 id="1-1-https如何保证安全的？加密方式？公私钥交换过程？"><a href="#1-1-https如何保证安全的？加密方式？公私钥交换过程？" class="headerlink" title="1.1 https如何保证安全的？加密方式？公私钥交换过程？"></a>1.1 https如何保证安全的？加密方式？公私钥交换过程？</h2><p>HTTP 直接和 TCP 通信，HTTPS则先和安全层（SSL/TLS）通信，然后安全层再和 TCP 层通信。</p>
<p><img src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/image-20220326155900535.png" alt="image-20220326155900535" loading="lazy"></p>
<p>SSL/TLS协议解决了HTTP存在的问题，包括：</p>
<ol>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ol>
<p>在采用<code>SSL</code>后，<code>HTTP</code>就拥有了<code>HTTPS</code>的加密、证书和完整性保护这些功能。</p>
<p>👉<a target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/HTTPS.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%81%9A">面试官：为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？ | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
<h2 id="1-2理解XSS，CSRF，DDOS攻击原理以及避免方式"><a href="#1-2理解XSS，CSRF，DDOS攻击原理以及避免方式" class="headerlink" title="1.2理解XSS，CSRF，DDOS攻击原理以及避免方式"></a>1.2理解XSS，CSRF，DDOS攻击原理以及避免方式</h2><blockquote>
<ol>
<li>详细介绍XSS，CSRF,怎么防范，它们之间的区别，追问数字证书的作用</li>
</ol>
</blockquote>
<p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p><strong>XSS避免方式：</strong></p>
<ol>
<li> <code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li>
<li> 尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</li>
<li> 使用特殊符号、标签转义符。</li>
</ol>
<p><code>CSRF</code>避免方式：</p>
<ol>
<li><p> 添加验证码</p>
</li>
<li><p>使用token</p>
<ul>
<li>  服务端给用户生成一个token，加密后传递给用户</li>
<li>  用户在提交请求时，需要携带这个token</li>
<li>  服务端验证token是否正确</li>
</ul>
</li>
</ol>
<p><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p>
<p><strong><code>DDos</code>避免方式：</strong></p>
<ol>
<li> 限制单IP请求频率。</li>
<li> 防火墙等防护设置禁止<code>ICMP</code>包等</li>
<li> 检查特权端口的开放</li>
</ol>
<p>👉<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&amp;mid=2247487116&amp;idx=1&amp;sn=09187eeb7e45faa1bee86ff48ae14be1&amp;source=41#wechat_redirect">360技术：嗨，送你一张Web性能优化地图</a></p>
<h2 id="1-3-Cookie、sessionStorage、localStorage-的区别"><a href="#1-3-Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="1.3 Cookie、sessionStorage、localStorage 的区别"></a>1.3 Cookie、sessionStorage、localStorage 的区别</h2><blockquote>
<ol>
<li>详细介绍cookie，比较cookie sessionStorage localStorage 区别，怎么保护cookie不被泄露。</li>
</ol>
</blockquote>
<p><strong>相同点</strong>：</p>
<ul>
<li>存储在客户端</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
<li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
</ul>
<h3 id="cookie的安全性"><a href="#cookie的安全性" class="headerlink" title="cookie的安全性"></a>cookie的安全性</h3><ol>
<li><p>cookie如此重要，在浏览器端，如果一个网站可以访问其他网站的cookie，肯定不行的，所以浏览器是不允许跨域访问cookie的，提高了Cookie的安全性。</p>
</li>
<li><p>HTTP设置cookie时，提供了2个属性，可以增强cookie的安全性，分别是secure属性和httpOnly属性。secure属性可防止信息在传递的过程中被监听捕获后导致信息泄露，如果设置为true，可以限制只有通过https访问时，才会将浏览器保存的cookie传递到服务端，如果通过http访问，不会传递cookie。httpOnly属性可以防止程序获取cookie，如果设置为true，通过js等将无法读取到cookie，能有效的防止XSS攻击。</p>
</li>
</ol>
<p>👉<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903573705211918">单点登录与权限管理本质：cookie安全问题 - 掘金 (juejin.cn)</a></p>
<hr>
<h2 id="1-4-HTTP报文的组成成分"><a href="#1-4-HTTP报文的组成成分" class="headerlink" title="1.4 HTTP报文的组成成分"></a>1.4 HTTP报文的组成成分</h2><blockquote>
<ol>
<li>你了解有哪些 HTTP 头字段 -&gt; <strong>说的越多越好</strong></li>
</ol>
</blockquote>
<p>请求报文{ 请求行、请求头、空行、请求体 } 请求行：{http方法、页面地址、http协议、http版本} 响应报文{ 状态行、响应头、空行、响应体 }</p>
<p><strong>Request Header:</strong></p>
<ol>
<li><strong>GET /sample.Jsp HTTP/1.1</strong> &nbsp;//请求行</li>
<li><strong>Host:</strong> &nbsp;<a target="_blank" rel="noopener" href="http://www.uuid.online/">www.uuid.online/</a> //请求的目标域名和端口号</li>
<li><strong>Origin:</strong>&nbsp;<a target="_blank" rel="noopener" href="http://localhost:8081/">http://localhost:8081/</a>  //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li>
<li><strong>Referer:</strong> <a target="_blank" rel="noopener" href="https://localhost:8081/link?query=xxxxx">https://localhost:8081/link?query=xxxxx</a> //请求资源的完整URI</li>
<li><strong>User-Agent:</strong>&nbsp;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&nbsp;//浏览器信息</li>
<li><strong>Cookie:</strong> &nbsp;BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0&nbsp;&nbsp;//当前域名下的Cookie</li>
<li><strong>Accept:</strong>&nbsp;text/html,image/apng&nbsp;&nbsp;//代表客户端希望接受的数据类型是html或者是png图片类型&nbsp;</li>
<li><strong>Accept-Encoding:</strong>&nbsp;gzip, deflate&nbsp;&nbsp;//代表客户端能支持gzip和deflate格式的压缩</li>
<li><strong>Accept-Language:</strong> zh-CN,zh;q=0.9&nbsp;&nbsp;//代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li>
<li><strong>Connection:</strong>&nbsp;keep-alive&nbsp;&nbsp;//告诉服务器，客户端需要的tcp连接是一个长连接</li>
</ol>
<p><strong>Response Header:</strong></p>
<ol>
<li><strong>HTTP/1.1 200 OK</strong>&nbsp;&nbsp;//&nbsp;响应状态行</li>
<li><strong>Date:</strong> &nbsp;Mon, 30 Jul 2018 02:50:55 GMT&nbsp;&nbsp;//服务端发送资源时的服务器时间</li>
<li><strong>Expires:</strong> &nbsp;Wed, 31 Dec 1969 23:59:59 GMT&nbsp;//比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li>
<li><strong>Cache-Control:</strong> &nbsp;no-cache&nbsp;&nbsp;// 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/amiezhang/p/9389537.html">博文”Cache-Control“</a></li>
<li><strong>etag:</strong> &nbsp;“fb8ba2f80b1d324bb997cbe188f28187-ssl-df”&nbsp;&nbsp;// 一般是<a target="_blank" rel="noopener" href="http://www.t086.com/article/5207">Nginx静态服务器</a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li>
<li><strong>Last-Modified:</strong> &nbsp;Fri, 27 Jul 2018 11:04:55 GMT&nbsp;//是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li>
<li><strong>Content-Type:</strong> &nbsp;text/html; charset=utf-8&nbsp;&nbsp;//如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li>
<li><strong>Content-Encoding:</strong> &nbsp;gzip&nbsp;&nbsp;//告诉客户端，应该采用gzip对资源进行解码</li>
<li><strong>Connection:</strong> &nbsp;keep-alive&nbsp;&nbsp;//告诉客户端服务器的tcp连接也是一个长连接</li>
</ol>
<hr>
<h2 id="1-5-http2-0和http1-0"><a href="#1-5-http2-0和http1-0" class="headerlink" title="1.5 http2.0和http1.0"></a>1.5 http2.0和http1.0</h2><blockquote>
<ol>
<li>http2.0和http1.0的区别</li>
</ol>
</blockquote>
<p>HTTP1.0：</p>
<ul>
<li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</li>
</ul>
<p>HTTP1.1：</p>
<ul>
<li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li>
<li>在同一个TCP连接里面，客户端可以同时发送多个请求</li>
<li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li>
<li>新增了一些请求方法</li>
<li>新增了一些请求头和响应头</li>
</ul>
<p>HTTP2.0：</p>
<ul>
<li>采用二进制格式而非文本格式</li>
<li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li>
<li>使用报头压缩，降低开销</li>
<li>服务器推送</li>
</ul>
<hr>
<h2 id="1-6-https和http"><a href="#1-6-https和http" class="headerlink" title="1.6 https和http"></a>1.6 https和http</h2><blockquote>
<ol>
<li>https和http之间的区别，https握手过程</li>
<li>介绍一下https，讲一下http2.0，它性能上有什么缺陷</li>
</ol>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>Https 协议需要 ca 证书，费用较高。 </li>
<li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li>
<li>http 的连接很简单，是无状态的。</li>
</ul>
<p>👉<a target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http">面试官：什么是HTTP? HTTP 和 HTTPS 的区别? | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
<h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h4><p><img src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/c42bc6f45451457fa6d614fb27534516_tplv-k3u1fbpfcp-watermark.png" alt="c42bc6f45451457fa6d614fb27534516_tplv-k3u1fbpfcp-watermark" loading="lazy"></p>
<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>
<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li>
<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>
<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>
</ol>
<blockquote>
<p>记忆口诀：一连二传三协商，四建五得六使用。</p>
</blockquote>
<hr>
<h2 id="1-7HTTP缓存（强制缓存-amp-amp-协商缓存）"><a href="#1-7HTTP缓存（强制缓存-amp-amp-协商缓存）" class="headerlink" title="1.7HTTP缓存（强制缓存&amp;&amp;协商缓存）"></a>1.7HTTP缓存（强制缓存&amp;&amp;协商缓存）</h2><blockquote>
<ol>
<li>HTTP缓存谈谈(越多越好</li>
<li><strong>浏览器缓存</strong>,强缓存、协商缓存,为什么cache-control优先级更高</li>
<li>no-cache,no-store分别代表什么</li>
<li>浏览器缓存机制</li>
<li>谈谈<strong>浏览器缓存</strong></li>
<li>http缓存控制，协商缓存？</li>
<li>http中缓存相关的一些header？ </li>
</ol>
</blockquote>
<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片" loading="lazy"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>  浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>  浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p>
<ul>
<li><p><strong>强制缓存</strong></p>
<p>  <code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p>
<p>  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<ol>
<li> 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li> 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li> 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ol>
</li>
<li><p><strong>协商缓存</strong></p>
<p>  <code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p>
<ol>
<li> 协商缓存生效，返回304</li>
<li> 协商缓存失效，返回200和请求结果结果</li>
</ol>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p>
<p>传送门 👉 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6992843117963509791" title="https://juejin.cn/post/6992843117963509791"># 彻底理解浏览器的缓存机制</a></p>
<hr>
<h2 id="1-8-HTTP协议-TCP协议-Scoket协议的区别"><a href="#1-8-HTTP协议-TCP协议-Scoket协议的区别" class="headerlink" title="1.8 HTTP协议, TCP协议, Scoket协议的区别"></a>1.8 HTTP协议, TCP协议, Scoket协议的区别</h2><blockquote>
<ol>
<li>http协议和socket协议区别，面试官提出了长短连接区别</li>
</ol>
</blockquote>
<p>HTTP是应用层的协议，更靠近用户端；TCP是传输层的协议；而socket是从传输层上抽象出来的一个抽象层，本质是接口。</p>
<p><img src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/9dbde0322cc1482fa17b38a4e3bfe664.jpg" alt="9dbde0322cc1482fa17b38a4e3bfe664" loading="lazy"></p>
<p><strong>1、TCP连接与HTTP连接的区别</strong></p>
<p>HTTP是基于TCP的，客户端往服务端发送一个HTTP请求时第一步就是要建立与服务端的TCP连接，也就是先三次握手，“你好，你好，你好”。从HTTP 1.1开始支持持久连接，也就是一次TCP连接可以发送多次的HTTP请求。</p>
<p>小总结：HTTP基于TCP</p>
<p><strong>2、TCP连接与Socket连接的区别</strong></p>
<p>在图中我们提到，socket层只是在TCP/UDP传输层上做的一个抽象接口层，因此一个socket连接可以基于连接，也有可能基于UDP。基于TCP协议的socket连接同样需要通过三次握手建立连接，是可靠的；基于UDP协议的socket连接不需要建立连接的过程，不过对方能不能收到都会发送过去，是不可靠的，大多数的即时通讯IM都是后者。</p>
<p>小总结：Socket也基于TCP</p>
<p><strong>3、HTTP连接与Socket连接的区别</strong></p>
<p>区分这两个概念是比较有意义的，毕竟TCP看不见摸不着，HTTP与Socket是实实在在能用到的。</p>
<ul>
<li>HTTP是短连接，Socket(基于TCP协议的)是长连接。尽管HTTP1.1开始支持持久连接，但仍无法保证始终连接。而Socket连接一旦建立TCP三次握手，除非一方主动断开，否则连接状态一直保持。</li>
<li>HTTP连接服务端无法主动发消息，Socket连接双方请求的发送先后限制。这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。HTTP采用“请求-响应”机制，在客户端还没发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。Socket连接双方类似peer2peer的关系，一方随时可以向另一方喊话。</li>
</ul>
<p><strong>4、什么时候该用HTTP，什么时候该用socket</strong></p>
<p>这个问题的提出是很自然而然的。当你接到一个与另一方的网络通讯需求，自然会考虑用HTTP还是用Socket。</p>
<ul>
<li>用HTTP的情况：双方不需要时刻保持连接在线，比如客户端资源的获取、文件上传等。</li>
<li>用Socket的情况：大部分即时通讯应用(QQ、微信)、聊天室等等。</li>
</ul>
<p>👉<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903970477981704">HTTP、Socket、TCP的区别 - 掘金 (juejin.cn)</a></p>
<hr>
<h2 id="1-9-HTTP常用的请求方法"><a href="#1-9-HTTP常用的请求方法" class="headerlink" title="1.9 HTTP常用的请求方法"></a>1.9 HTTP常用的请求方法</h2><ul>
<li>GET—获取资源</li>
<li>POST—传输资源</li>
<li>PUT—更新资源</li>
<li>DELETE—删除资源</li>
<li>HEAD—获取报文首部</li>
</ul>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><blockquote>
<ol>
<li>http中常见的请求方法有哪些？GET和POST的区别？</li>
<li>简单请求和复杂请求，get与post区别，应用场景？在项目中的使用？</li>
</ol>
</blockquote>
<p><strong>1. 浏览器回退表现不同</strong> GET在浏览器回退时是无害的，而POST会再次提交请求<br><strong>2. 浏览器对请求地址的处理不同</strong> GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置<br><strong>3. 浏览器对响应的处理不同</strong>GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留<br><strong>4. 参数大小不同.</strong> GET请求在URL中传送的参数是有长度的限制，而POST没有限制<br><strong>5. 安全性不同.</strong> GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全<br><strong>6. 针对数据操作的类型不同</strong>.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。</p>
<h2 id="2-0-HTTP状态码"><a href="#2-0-HTTP状态码" class="headerlink" title="2.0 HTTP状态码"></a>2.0 HTTP状态码</h2><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>1xx：指示信息类，表示请求已接受，继续处理</li>
<li>2xx：指示成功类，表示请求已成功接受</li>
<li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li>
<li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：指示服务器错误，服务器未能实现合法的请求</li>
</ul>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li><p>200 OK：客户端请求成功</p>
</li>
<li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的URL</p>
</li>
<li><p>302 Found：所请求的页面已经临时重定向至新的URL</p>
</li>
<li><p>304 Not Modified 未修改。</p>
</li>
<li><p>403 Forbidden：对请求页面的访问被禁止</p>
</li>
<li><p>404 Not Found：请求资源不存在</p>
</li>
<li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p>
</li>
<li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p>
</li>
<li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p>
<ul>
<li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li>
<li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li>
</ul>
</li>
<li><p>2xx（成功）表示成功处理了请求的状态码</p>
<ul>
<li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li>
<li>201 - 已创建 请求成功并且服务器创建了新的资源</li>
<li>202 - 已接受 服务器已接受请求，但尚未处理</li>
<li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li>
<li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li>
<li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li>
</ul>
</li>
<li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p>
<ul>
<li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li>
<li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li>
<li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</li>
<li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li>
<li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li>
<li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li>
</ul>
</li>
<li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p>
<ul>
<li><code>400</code> - 错误请求 服务器不理解请求的语法</li>
<li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li><code>403</code> - 禁止 服务器拒绝请求</li>
<li><code>404</code> - 未找到 服务器找不到请求的网页</li>
<li>405 - 方法禁用 禁用请求中指定的方法</li>
<li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li>
<li><code>407</code> - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理</li>
<li><code>408</code> - 请求超时 服务器等候请求时发生超时</li>
<li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li>
<li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li>
<li><code>414</code> - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理</li>
</ul>
</li>
</ul>
<ul>
<li>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错<ul>
<li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li>
<li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li>
<li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器收到无效响应</li>
<li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li>
<li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li>
<li>505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2. 跨域"></a>2. 跨域</h1><blockquote>
<ol>
<li>跨域是什么？产生条件？在微信小程序中的运用？解决了什么？</li>
<li>解决跨域有哪些方法，他们的原理，怎么实现cookie跨域，</li>
<li>浏览器不同标签页面通信？同源、跨域情况下？（可能我一直都没答到点子上，一直让我说有没有其他的方案，说了好几个能想到的，包括storage api,server侧配合websocket甚至外部应用程序</li>
<li>JSONP、CORS（简单请求和非简单请求）、前端脚手架配置、Nginx反向代理、Websocket（没有同源限制）</li>
<li>设置代理的原理，代理为何能实现跨域，具体属性等。</li>
</ol>
</blockquote>
<ol>
<li><p>跨域的原理</p>
<p> <strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。跨域访问是被各大浏览器所默认禁止的。<br> <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br> <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
</li>
<li><p>解决方案</p>
<p> 最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p>
<ul>
<li><p><strong>JSONP</strong>：<br>  ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>  步骤：</p>
<ol>
<li> 去创建一个script标签</li>
<li> script的src属性设置接口地址</li>
<li> 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li> 通过定义函数名去接受返回的数据</li>
</ol>
  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//动态创建 script</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置回调函数</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//设置 script 的 src 属性，并设置请求地址</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/?callback=getData'</span><span class="token punctuation">;</span>

<span class="token comment">// 让 script 生效</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  <strong>JSONP 的缺点</strong>:<br>  JSONP 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
</li>
<li><p>  <strong><code>document.domain</code></strong> 基础域名相同 子域名不同（a.test.com和b.test.com通信，二级域名相同）— 同源跨域</p>
</li>
<li><p>  <strong><code>window.name</code></strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name—不同标签页通信</p>
</li>
<li><p><strong><code>postMessage</code></strong> 实现跨域通信和页面间数据通信（H5提供的安全跨域通信API）</p>
</li>
<li><p><strong>CORS</strong><br>  CORS(Cross-origin resource sharing)跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置<code>Access-Control-Allow-Origin</code> HTTP响应头之后，浏览器将会允许跨域请求</p>
<p>  1.浏览器端会自动向请求头添加origin字段，表明当前请求来源。<br>  2.服务器设置<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等 HTTP响应头字段之后，浏览器将会允许跨域请求。</p>
<p>  <strong>预检</strong>(复杂请求)</p>
<p>  但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。</p>
<p>  OPTIONS请求返回以下报文</p>
<p>  <code>HTTP/2.0 20 OK</code><br>  <code>Access-Control-Allow-Origin:https://a.com</code><br>  <code>Access-Control-Allow-Methods:POST,GET,OPTIONS</code><br>  <code>Access-Control-Allow-Headers:X-ABC,Content-Type</code></p>
<pre><code>  Access-Control-Max-Age:86400 // 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了
</code></pre>
<p>  浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。</p>
<p>  整体的过程cors将请求分为2种，<strong>简单请求和复杂请求，</strong>需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的<u>缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</u></p>
</li>
</ul>
<ul>
<li>配置反向代理</li>
</ul>
</li>
</ol>
<pre><code>- 最方便的跨域方案 **proxy代理+ Nginx**
    nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。

    跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。

    反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。
</code></pre>
<p>跨域传送门  👉<a target="_blank" rel="noopener" href="https://juejin.cn/post/7003232769182547998"># 跨域，不可不知的基础概念</a></p>
<h1 id="3-从输入URL到页面加载的全过程"><a href="#3-从输入URL到页面加载的全过程" class="headerlink" title="3. 从输入URL到页面加载的全过程"></a>3. 从输入URL到页面加载的全过程</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-1.image" alt="从输入URL到页面加载的主干流程" loading="lazy"></p>
<p><img src="https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p>
<ol>
<li><p> 首先在浏览器中输入URL</p>
</li>
<li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p>
<ul>
<li>  浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li>
<li>  操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li>
<li>  路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li>
<li>  ISP缓存：若上述均失败，继续向ISP搜索。</li>
</ul>
</li>
<li><p> DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p>
</li>
<li><p> 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p>
</li>
<li><p> 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p>
</li>
<li><p> 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p>
</li>
<li><p> 关闭TCP连接：通过四次挥手释放TCP连接</p>
</li>
<li><p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p>
<ul>
<li>  构建DOM（文档对象模型）树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li>
<li>  构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li>
<li>  构建render树：Web浏览器将DOM和CSS OM结合，并构建出渲染树（render tree）</li>
<li>  布局（Layout）：计算出每个节点在屏幕中的位置</li>
<li>  绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-1.image" alt="浏览器渲染流程图" loading="lazy"></p>
</li>
<li><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p>
<ul>
<li>  创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li>
<li>  加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li>
<li>  预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（==匿名函数是不参与预编译的，因为它是变量==）。<u>而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</u></li>
<li>  解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。<strong>JS作用域</strong>其实就是这样的执行流机制实现的。</li>
</ul>
</li>
</ol>
<p>传送门 👉 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7005468491067162655"># DNS域名解析过程</a> ☞<a target="_blank" rel="noopener" href="https://juejin.cn/post/6992597760935460901"># 浏览器的工作原理</a></p>
<hr>
<h1 id="4-在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？"><a href="#4-在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？" class="headerlink" title="4. 在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？"></a>4. 在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</h1><blockquote>
<ol>
<li>Html解析的过程中有哪些事件;</li>
<li>浏览器解析HTML的过程</li>
</ol>
</blockquote>
<p>浏览器要将URL解析为IP地址，解析域名就要用到<code>DNS协议</code>，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议。</code></p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到<code>TCP协议</code>。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他<code>物理层协议</code>，比如PPP，SLIP)，以太网协议需要知道目的IP地址的物理地址，又需要<code>ARP协议</code>。</p>
<p>其中：</p>
<p>1、<code>DNS协议，http协议，https协议属于应用层</code></p>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<p>2、<code>TCP/UDP属于传输层</code></p>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<p>3、<code>IP协议属于网络层</code></p>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p>
<p>4、<code>ARP协议属于数据链路层</code></p>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p>
<p>5、物理层</p>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<hr>
<h1 id="5-TCP-IP协议"><a href="#5-TCP-IP协议" class="headerlink" title="5. TCP/IP协议"></a>5. TCP/IP协议</h1><blockquote>
<ol>
<li>TCP/UDP是在哪一层，有什么区别</li>
<li>三次握手 四次挥手,为什么挥手多一次</li>
<li>TCP三次握手，四次挥手</li>
<li>TCP拥塞控制，有什么缺点</li>
<li>tcp与udp区别？应用场景？</li>
<li>OSI七层模型，网络协议为什么要分层</li>
</ol>
</blockquote>
<h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h2><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li>  链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li>
<li>  网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
<li>  传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li>  应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa80b3b48a84bd18d8e708c56a1dc22~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></p>
<ol>
<li> 第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li> 第二次握手：<code>服务器收到syn包并确认客户端的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li> 第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="未命名图片" loading="lazy"></p>
<p>1）<code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
<p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol>
<li><p>TCP是面向<code>连接</code>的，而UDP是面向无连接的。</p>
</li>
<li><p>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p>
</li>
<li><p>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p>
</li>
</ol>
<hr>
<h1 id="6-DNS与CDN"><a href="#6-DNS与CDN" class="headerlink" title="6. DNS与CDN"></a>6. DNS与CDN</h1><blockquote>
<ol>
<li><p>DNS端口号</p>
</li>
<li><p>CDN和DNS之间的关系</p>
</li>
</ol>
</blockquote>
<p>👉<a target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/DNS.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">面试官：DNS协议 是什么？说说DNS 完整的查询过程? | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
<p>👉<a target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/CDN.html">面试官：如何理解CDN？说说实现原理？ | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
<hr>
<h1 id="7-进程与线程"><a href="#7-进程与线程" class="headerlink" title="7. 进程与线程"></a>7. 进程与线程</h1><blockquote>
<ol>
<li><p>进程和线程的区别</p>
</li>
<li><p>浏览器中一个页面是一个进程还是一个线程，某个页面崩溃后会影响整个进程吗？</p>
</li>
<li><p>进程间通信</p>
</li>
<li><p>死锁的条件</p>
</li>
</ol>
</blockquote>
<p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p>
<p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p>
<p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p>
<h2 id="7-1-进程和线程的区别与联系"><a href="#7-1-进程和线程的区别与联系" class="headerlink" title="7.1 进程和线程的区别与联系"></a>7.1 进程和线程的区别与联系</h2><p>【区别】：</p>
<p>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p>
<p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p>
<p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p>
<p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<p>【联系】：</p>
<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
<p>传送门 ☞ <a target="_blank" rel="noopener" href="https://juejin.cn/post/7005465381791875109"># 一文搞懂进程、线程、协程及JS协程的发展</a><br><a target="_blank" rel="noopener" href="http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml">☞了解更多</a></p>
<p>[计算机操作系统 - 进程管理 | CS-Notes (cyc2018.xyz)](<a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">http://www.cyc2018.xyz/计算机基础/操作系统基础/计算机操作系统</a> - 进程管理.html#_4-管程)</p>
<p>关于浏览器传送门 ☞<a target="_blank" rel="noopener" href="https://juejin.cn/post/6993095345576083486"># 深入了解现代 Web 浏览器</a></p>
<h2 id="7-2-进程间的通信方式"><a href="#7-2-进程间的通信方式" class="headerlink" title="7.2 进程间的通信方式"></a>7.2 进程间的通信方式</h2><p><code>进程通信</code>：<br>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过<code>内核</code>,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p>
<p>进程间的通信方式：管道、有名管道、信号、消息队列、共享内存、信号量、socket</p>
<p><code>匿名管道( pipe )</code>： 管道是一种半双工的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong>。</p>
<p><code>高级管道(popen)</code>：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们称为高级管道方式。</p>
<p><code>有名管道 (named pipe) </code>： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p><code>消息队列( message queue )</code> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p><code>信号量( semophore )</code> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><code>信号 ( sinal )</code> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><code>共享内存( shared memory )</code> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><code>套接字( socket ) 通信</code>： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="7-3-死锁"><a href="#7-3-死锁" class="headerlink" title="7.3 死锁"></a>7.3 死锁</h2><hr>
<h1 id="8-常见数据结构"><a href="#8-常见数据结构" class="headerlink" title="8. 常见数据结构"></a>8. 常见数据结构</h1><blockquote>
<p>你知道哪些数据结构</p>
<ul>
<li>堆和栈的区别</li>
<li>冒泡排序</li>
<li>二分查找</li>
</ul>
</blockquote>
<ul>
<li><p>B端页面？<strong>页面优化</strong>的方法？<br>* </p>
</li>
<li><p>前端设计模式</p>
</li>
<li><p>html、css、js文件会放在磁盘缓存还是内存缓存</p>
</li>
<li><p>DOM树和css om树是互斥的还是同时的</p>
</li>
<li><p>JS脚本阻塞DOM构建,js脚本会不会对css om树影响</p>
</li>
<li><p>多路复用怎么实现的</p>
</li>
<li><p>之后介绍token，具体原理，怎么应用。</p>
</li>
<li><ul>
<li></li>
<li></li>
</ul>
</li>
<li></li>
<li><p>* </p>
</li>
<li><p>useragent浏览器信息</p>
</li>
<li><p>* </p>
</li>
<li><p>Number正负数分别怎么表示，给原码写补码</p>
</li>
<li><p>base64编码的原理和优缺点</p>
</li>
<li><p>前端路由怎么实现的，原理</p>
<ul>
<li>前端路由有哪几种</li>
</ul>
</li>
<li><p>讲讲websocket</p>
<ul>
<li>webpack原理和编译流程</li>
</ul>
</li>
<li><p>单页应用和多页应用对比</p>
</li>
<li><p>node底层原理 node单线程的好处</p>
</li>
<li><p>前端权限</p>
</li>
<li><p>图片懒加载（滚动加载</p>
<ul>
<li><p>img容器标签设置data-src为真实图片地址，判断图片容器的scrollTop与视图窗口高度clientHeight+窗口滚动过的距离scrollTop的大小关系</p>
</li>
<li><p>图片容器出现在可视区，就将其data-src属性赋值给src，加载图片</p>
</li>
</ul>
</li>
<li><p>路由懒加载原理？</p>
<ul>
<li><p>路由配置懒加载后，需要被懒加载的路由文件被单独打包成一个chunk文件 </p>
</li>
<li><p>在打包出来的HTML模板中配置该chunk文件为预提取，在浏览器空闲时加载路由文件 </p>
</li>
<li><p> 在切换到对应路由时，通过函数引入预提取的路由文件，实现懒加载</p>
</li>
</ul>
</li>
<li><p>首屏加载如何优化？</p>
<ul>
<li>webpack配置分包，externals，静态资源压缩，静态资源缓存，路由懒加载，图片懒加载，防抖，节流</li>
</ul>
</li>
<li><p>场景题，后端给你一万条数据，如何展示？ </p>
<ul>
<li> 指定一个渲染容器，可以滚动，初始渲染少量数据 </li>
<li> 在滚动这个容器列表的时候，当最后一个元素出现在可视区，再渲染部分数据 </li>
<li> 如果存在大量的DOM操作可以通过文档碎片来批量操作</li>
</ul>
</li>
<li><p>如果需要保存上一次用户的操作结果，怎么做？</p>
<ul>
<li>通过浏览器本地存储缓存数据，下次访问页面时，判断本地存储有无数据，进而条件渲染</li>
</ul>
</li>
<li><p>在前端常用的debug的手段？chrome的哪些部分分别能看到什么方面？</p>
</li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192029.jpg"><img loading="lazy" src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192029.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192027.png"><img loading="lazy" src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192027.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192028.png"><img loading="lazy" src="https://typora-lee.oss-cn-chengdu.aliyuncs.com/img-typora/20210616192028.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>elegantlee</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://elegantlee.github.io/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/" title="面经重点-408">https://elegantlee.github.io/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-CSS/" rel="prev" title="面经重点-HTML&amp;CSS"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">面经重点-HTML&amp;CSS</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/03/25/%E9%9D%A2%E7%BB%8F/LeetCode/" rel="next" title="LeetCode刷题"><span class="post-nav-text">LeetCode刷题</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/ElegantLee/elegantlee.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="waline"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js", () => {
  const walineConfig = {"enable":true,"serverURL":"https://elegantlee-github-io.vercel.app","comment":true,"visitor":true,"placeholder":"填写邮箱，可以收到回复通知哦～","requiredFields":["nick"],"el":"#waline","lang":"zh-CN"}
  walineConfig.path = "/2022/03/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F%E9%87%8D%E7%82%B9-408/"
  new Waline(walineConfig)
}, window.Waline);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> elegantlee</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.1</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div class="live_time"><span>本博客已坚挺地运行</span><span id="display_live_time"></span><span class="moe-text">(ง •_•)ง</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-06-14T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div></body></html>